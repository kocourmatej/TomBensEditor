<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///grid init

max_surfaces=5;    //pro rychlejší ladění ( později přidat nebo dynamicky zvětšovat pomocí resize )
grid_arguments=16;

//LIST ARGUMENTŮ V MAKRECH

g=ds_grid_create(grid_arguments,max_surfaces);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mrizka defaults

guides=on;

mrizka_w=100;
mrizka_h=100;
mrizka_x=20;
mrizka_y=30;

mrizka_snap=false;
cursor_blink_time=room_speed/3;
cursor_stay=cursor_blink_time/2;
alarm[0]=cursor_blink_time;
window_set_cursor(cr_none);
grid_moving=0;
grid_resizing=0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicializace ostatních proměnných

g_reset_defaults();

//jeden surface jako zdroj obsahu - vytvoření v Draw
ssource=surface_create(room_width,room_height); // je nutné vytvořit alespoň jeden povrch, aby se index 0 nevyskytoval v grid



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>window_set_cursor(cr_default);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///repeat cursor blink
alarm[0]=cursor_blink_time;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mrizka výpočet polohy kursoru
 
 
//módy, které nepoužívají přitahování na mřížku
no_snap=oCursorMode.value==SELECT;
no_snap=no_snap || oCursorMode.value==KILL;
no_snap=no_snap || oCursorMode.value==DEPTH;
no_snap=no_snap || oCursorMode.value==GMOVE;
no_snap=no_snap || oCursorMode.value==GSIZE;

//kurzor v menu
if (mouse_y&lt;oCursorMode.safe_area &amp;&amp; oCursorMode.visible==1)
  { no_snap=1; window_set_cursor(cr_default); event_perform(ev_mouse,ev_global_right_release); } 
else 
  { window_set_cursor(cr_none); }

//přichytávač
if mrizka_snap &amp;&amp; !no_snap 
{
if !keyboard_check_direct(ord('X')) Mx=(round(mouse_x/mrizka_w)*mrizka_w)+mrizka_x;   // klávesy X,Y znamenají axis lock
if !keyboard_check_direct(ord('Y')) My=(round(mouse_y/mrizka_h)*mrizka_h)+mrizka_y;
}
else
{
if !keyboard_check_direct(ord('X')) Mx=mouse_x;
if !keyboard_check_direct(ord('Y')) My=mouse_y;
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Přemisťování nebo změny velikosti (surface, mřížky..) - výpočet diferenciálu

//pohyb nebo změna velikosti surface
if (moving==1 || resizing==1) || rotating==1
{
dif_x= Mx - start_xx  ;  // X-ová souřadnice
dif_y= My - start_yy  ;  // Y-ová souřadnice
}

if grid_moving==1 
{
dif_x= Mx - start_xx  ;  // X-ová souřadnice
dif_y= My - start_yy  ;  // Y-ová souřadnice
dif_x= dif_x mod mrizka_w;
dif_y= dif_y mod mrizka_h;
}

if grid_resizing==1 
{
dif_x= Mx - start_xx  ;  // X-ová souřadnice
dif_y= My - start_yy  ;  // Y-ová souřadnice
}

if keyboard_check_direct(vk_shift) //aspect lock
{
var d=mean(dif_x,dif_y);
dif_x=d; dif_y=d;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="57">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///zanech všeho
moving=0;
resizing=0;
rotating=0;
grid_moving=0;
grid_resizing=0;
creating_surface=0;
io_clear();


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///moving - zastavení

    if (oCursorMode.value==MOVE) &amp;&amp; moving=1 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    
    for(i=0;i&lt;max_surfaces;i++) //pro všechny povrchy
    {
     if g[#_selected,i]==1 //které jsou vybrány
       {
        //položit
        if source_mode==0
        {
        g[#_x1,i]+=dif_x;        g[#_y1,i]+=dif_y;
        g[#_x2,i]+=dif_x;        g[#_y2,i]+=dif_y;
        }
        else
        {
        g[#_xs1,i]+=dif_x;        g[#_ys1,i]+=dif_y;
        g[#_xs2,i]+=dif_x;        g[#_ys2,i]+=dif_y;
        }
       }
    }
    
    moving = 0; // Posunujeme povrch
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///rotating - zastavení

    if (oCursorMode.value==ROTATE) &amp;&amp; rotating=1 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    
    for(i=0;i&lt;max_surfaces;i++) //pro všechny povrchy
    {
     if g[#_selected,i]==1 //které jsou vybrány
       {
        //položit
        g[#_angle,i]=mean(dif_x,dif_y);
       }
    }
    
    rotating = 0; // konec rotace
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///přesun mřížky - zastavení

    if (oCursorMode.value==GMOVE) &amp;&amp; grid_moving=1 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    
    mrizka_x=(mrizka_x+dif_x) mod mrizka_w;
    mrizka_y=(mrizka_y+dif_y) mod mrizka_h;
    
    grid_moving = 0; // konec posunu mřížky
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///změna velikosti mřížky - zastavení

    if (oCursorMode.value==GSIZE) &amp;&amp; grid_resizing=1
    {
    
    mrizka_w=(mrizka_w+dif_x);
    mrizka_h=(mrizka_h+dif_y);
    mrizka_w=clamp(mrizka_w,2,room_width);
    mrizka_h=clamp(mrizka_h,2,room_height);    
    
    grid_resizing = 0; // konec posunu mřížky
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///resizing a scaling - položení tahu myši

    if ((oCursorMode.value==RESIZE) || (oCursorMode.value==SCALE)) &amp;&amp; resizing=1 // mód kurzoru je RESIZE nebo SCALE
    {
    
    for(i=0;i&lt;max_surfaces;i++) //pro všechny povrchy
    {
     if g[#_selected,i]==1 //které jsou vybrány
       {
        //resize surface i zdroje ( nezamčený aspect )
        
        var Xkey=!keyboard_check_direct(ord('X'));
        var Ykey=!keyboard_check_direct(ord('Y'));
        
        var ZoomSurface = (oCursorMode.value==RESIZE) || !source_mode
        var ZoomSource = (oCursorMode.value==RESIZE) || source_mode
        
        var xr1=g[#_x1,i]-(dif_x*Xkey*ZoomSurface);
        var yr1=g[#_y1,i]-(dif_y*Ykey*ZoomSurface);
        var xr2=g[#_x2,i]+(dif_x*Xkey*ZoomSurface);
        var yr2=g[#_y2,i]+(dif_y*Ykey*ZoomSurface);
        
        var xrs1=g[#_xs1,i]-(dif_x*Xkey*ZoomSource);
        var yrs1=g[#_ys1,i]-(dif_y*Ykey*ZoomSource);
        var xrs2=g[#_xs2,i]+(dif_x*Xkey*ZoomSource);
        var yrs2=g[#_ys2,i]+(dif_y*Ykey*ZoomSource);
        
        //zápis do gridu se u RESIZE provede jen při nenulových velikostech
        if ((xr2-xr1)&gt;0 &amp;&amp; (yr2-yr1)&gt;0) &amp;&amp; ((xrs2-xrs1)&gt;0 &amp;&amp; (yrs2-yrs1)&gt;0)
        {
        
        if (oCursorMode.value==RESIZE) //při RESIZE se rovnou zapíší platné velikosti do gridu
        {
        g[#_x1,i]=xr1;
        g[#_y1,i]=yr1;
        g[#_x2,i]=xr2;
        g[#_y2,i]=yr2;
     
        g[#_xs1,i]=xrs1;
        g[#_ys1,i]=yrs1;
        g[#_xs2,i]=xrs2;
        g[#_ys2,i]=yrs2;
        }
        }
        
        //zatímco SCALE může mít hodnotu 0
        if (oCursorMode.value==SCALE) //při SCALE se spočte xscale,yscale a zapíší se do gridu
        {
        g[#_xscale,i]=(xr2-xr1)/(xrs2-xrs1);
        g[#_yscale,i]=(yr2-yr1)/(yrs2-yrs1);
        }
        
          
        
        //pokud není starý surface zrovna zneplatněn, zlikviduj ho
        if surface_exists (g[#_id,i]) surface_free(g[#_id,i]);
        //vytvoř nový s novou velikostí
        g[#_id,i]=surface_create(g[#_x2,i]-g[#_x1,i],g[#_y2,i]-g[#_y1,i]);
       }
    }
    
    resizing = 0; // Posunujeme povrch
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///dokončení tvorby nového a zápis do ds_

if (oCursorMode.value==ADD) &amp;&amp; creating_surface=1 // Pokud tvoříme povrch
   { 
        surface_x = abs(Mx-start_xx); // Šířka surface (prozatím unused)
        surface_y = abs(My-start_yy); // Výška surface (prozatím unused)
        
     if surface_x&gt;0 &amp;&amp; surface_y&gt;0 //invalid surface dimensions
       {   
        var position_in_grid=g_new_place();   
        
        g[#_id,position_in_grid]=surface_create(surface_x,surface_y); // Do listu uložíme nový povrch
        
        if surface_exists(g[#_id,position_in_grid]) 
              show_debug_message('New surface was created: '+string(g[#_id,position_in_grid])+' at '+string(position_in_grid))
         else show_debug_message('New surface was NOT created! ');
        
        // Do adekvátních sloupců gridu zapíšeme souřadnice x1,y1,x2,y2   
        g[#_x2,position_in_grid]=max(Mx,start_xx); 
        g[#_y2,position_in_grid]=max(My,start_yy);       
        g[#_x1,position_in_grid]=min(Mx,start_xx);
        g[#_y1,position_in_grid]=min(My,start_yy);
        
        //default pro flags
        g[#_baked,position_in_grid]=0;
        g[#_selected,position_in_grid]=0;
        g[#_depth,position_in_grid]=layer;
        g[#_group,position_in_grid]=group;
        
        //source je na začátku tam, kde poloha
        g[#_xs2,position_in_grid]=g[#_x2,position_in_grid]; 
        g[#_ys2,position_in_grid]=g[#_y2,position_in_grid];       
        g[#_xs1,position_in_grid]=g[#_x1,position_in_grid];
        g[#_ys1,position_in_grid]=g[#_y1,position_in_grid];
        
        //zvětšení je na začátku 1:1
        g[#_xscale,position_in_grid]=1;
        g[#_yscale,position_in_grid]=1;

        //rotace nulová
        g[#_angle,position_in_grid]=0;
        
       }
       
        creating_surface = 0; // Povrch je vytvořen, můžeme vynulovat proměnnou
   }
 
   
       
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///depth - inc 

if (oCursorMode.value = DEPTH) // Pakliže máme vybraný stav kursoru jako "kill"
    {
      var m = g_surface_under_mouse(); // Zjistíme zda a na který povrch se kliklo
      show_debug_message('Kliknuto na povrch: '+string(m));
     
     if (m != -1) //pod myší nějaký povrch je
      {
       m = g_surface_exists(m); //pozice v gridu      
       g[#_depth,m]++; // Zvýšíme hloubku
      }       
    }    
      
      
      
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///výběr - deselect all

    if (oCursorMode.value==SELECT) // mód kurzoru je SELECT
    {
    
    for(i=0;i&lt;max_surfaces;i++) //pro všechny povrchy
    {
     g[#_selected,i]=0 //deselect
    }

    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///výběr  

   if oCursorMode.value==SELECT
   {
     var m=g_surface_under_mouse();
     show_debug_message('Kliknuto na povrch: '+string(m));
     if m!=-1 //pod myší nějaký povrch je
      {
       m=g_surface_exists(m); //pozice v gridu
       g[#_selected,m]=!g[#_selected,m]; //select/deselect
      }                   
   }    
    

        

   
   
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///zničení   
if (oCursorMode.value = KILL) // Pakliže máme vybraný stav kursoru jako "kill"
    {
      var m=g_surface_under_mouse();
      show_debug_message('Kliknuto na povrch: '+string(m));
     
     if m!=-1 //pod myší nějaký povrch je
      {
       m=g_surface_exists(m); //pozice v gridu
       surface_free(g[#_id,m]);
       ds_grid_set_region(g,0,m,grid_arguments-1,m,0); //reset values
      }       
    }    
      
      
      
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start move

    if (oCursorMode.value==MOVE)&amp;&amp; moving==0 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    moving = 1; // Posunujeme povrchy
   
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = Mx;  // X-ová souřadnice
    start_yy = My;  // Y-ová souřadnice
    
    }
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start rotate

    if (oCursorMode.value==ROTATE)&amp;&amp; rotating==0 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    rotating = 1; // Posunujeme povrchy
   
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = Mx;  // X-ová souřadnice
    start_yy = My;  // Y-ová souřadnice
    
    }
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start přesunu mřížky - GMOVE

    if (oCursorMode.value==GMOVE)&amp;&amp; grid_moving==0 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    grid_moving = 1; // Posunujeme povrchy
   
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = Mx;  // X-ová souřadnice
    start_yy = My;  // Y-ová souřadnice
    
    }
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start resize nebo scale

    if ((oCursorMode.value==RESIZE) || (oCursorMode.value==SCALE)) &amp;&amp; resizing==0 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    resizing = 1; // Posunujeme povrchy
   
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = Mx;  // X-ová souřadnice
    start_yy = My;  // Y-ová souřadnice
    
    }
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start změny velikosti mřížky

    if (oCursorMode.value==GSIZE) // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    grid_resizing = 1; // škálujeme mřížku
   
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = Mx;  // X-ová souřadnice
    start_yy = My;  // Y-ová souřadnice
    
    }
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///depth - dec  

if (oCursorMode.value = DEPTH) // Pakliže máme vybraný stav kursoru jako "kill"
    {
      var m = g_surface_under_mouse(); // Zjistíme zda a na který povrch se kliklo
      show_debug_message('Kliknuto na povrch: '+string(m));
     
     if (m != -1) //pod myší nějaký povrch je
      {
       m = g_surface_exists(m); //pozice v gridu      
       g[#_depth,m]--; // Snížíme hloubku
      }       
    }    
      
      
      
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start tvoření nového   
    
    if (oCursorMode.value==ADD) // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    creating_surface = 1; // Vytváříme nový povrch
    
    
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = Mx;  // X-ová souřadnice
    start_yy = My;  // Y-ová souřadnice
    
    }
        

   
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///SAVE

save_grid_content(g);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///LOAD

load_grid_content(g);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///KILL ALL
g_reset_defaults(true);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// na zvážení - HTML export se pravděpodobně konat nebude
draw_set_color(c_black);
draw_set_alpha(1);




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vyplnění zdrojového surface
if !surface_exists(ssource) ssource=surface_create(room_width,room_height);

// už by měl existovat - vyplnit
  surface_set_target(ssource);
  draw_background_tiled_ext
    ( 
    background0,   //index
    image_index,0, //poloha - jízda
    2,2,            //zvětšit
    c_white,1      //blend
    )
   surface_reset_target();
   
if source_mode==1
{
 draw_surface(ssource,x,y);
}   


 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Obdélník při vytváření

if (oCursorMode.value==ADD) &amp;&amp; (creating_surface==1) // Pokud tvoříme povrch
   {
    draw_rectangle(start_xx,start_yy,Mx,My,1); // Vykreslíme obdélník od počátečních k aktuálním souřadnicím kurzoru
   }
   
   
   

   
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vykreslení všech surfaces a manipulačních obrysů

   
       //první by se měly vykreslit ty s nejnižší depth, stejné depth pak podle pořadí vytvoření
       ds_grid_sort(g,_id,sestupne); 
       ds_grid_sort(g,_depth,sestupne);
       
   for(i=0;i&lt;max_surfaces;i++)
    {
          
     if g[#_id,i]!=0  //nulový index je rezervován pro ssource a nula v grid znamená prázdné pole
          {
          
           //dočasné proměnné x1,y1,x2,y2 kopírují aktuální stav v gridu
             var x1,y1,x2,y2;
               
               if source_mode==0
               {
                x1=g[#_x1,i];
                y1=g[#_y1,i];
                x2=g[#_x2,i];
                y2=g[#_y2,i];
               }
               
          //pokud surface neexistuje, ale záznam je, vytvoří se podle záznamu
            if !surface_exists(g[#_id,i])
              {
               var w=x2-x1;
               var h=y2-y1;
               
               if (w&gt;0 &amp;&amp; h&gt;0) g[#_id,i]=surface_create(w,h);  //vytvoří se, pokud není velikost nula     
              }
              
             //pokud surface neexistuje, nekreslí se nic
             if surface_exists(g[#_id,i]) 
             {
               if source_mode==1
               {
                x1=g[#_xs1,i];
                y1=g[#_ys1,i];
                x2=g[#_xs2,i];
                y2=g[#_ys2,i];
               }
                    
                 
               //obsah kopíruje source pokud není zapečen
               if g[#_baked,i]==0 surface_copy_part(g[#_id,i],0,0,ssource,g[#_xs1,i],g[#_ys1,i],g[#_xs2,i]-g[#_xs1,i],g[#_ys2,i]-g[#_ys1,i]);
               //--
               
               //obrys pro nevybraný povrch
               if (!g[#_selected,i]) {draw_rectangle(x1-1,y1-1,x2,y2,1);}
               //--

               
               //zoomshift
               var zsx=((1-g[#_xscale,i])*(x2-x1)*!source_mode)/2;
               var zsy=((1-g[#_yscale,i])*(y2-y1)*!source_mode)/2;
               
               
               // vykreslíme iterovaný povrch
               if source_mode==0
               {
                if keyboard_check_direct(ord('H')) //dočasně skryje nevybrané
                 { if (g[#_selected,i]) draw_surface_ext(g[#_id,i],x1+zsx,y1+zsy,g[#_xscale,i],g[#_yscale,i],g[#_angle,i],c_white,1); }
                else
                 { draw_surface_ext(g[#_id,i],x1+zsx,y1+zsy,g[#_xscale,i],g[#_yscale,i],g[#_angle,i],c_white,1); }
               }
               else
               {
                if keyboard_check_direct(ord('H')) //dočasně skryje nevybrané
                 { if (g[#_selected,i]) draw_surface(g[#_id,i],x1,y1); }
                else
                 { draw_surface(g[#_id,i],x1,y1); }
 
               }
               //--
               
               
               /**** Pomocné obrysy pro transformace ****/
               
               //měníme velikost - vykreslení obrysu
               if g[#_selected,i]=1 &amp;&amp; resizing==1
               {
                draw_rectangle(x1-dif_x,y1-dif_y,x2+dif_x,y2+dif_y,1);
               }
               //-- 
               
               //pohybujeme - vykreslení obrysu
               if g[#_selected,i]=1 &amp;&amp; moving==1
               {
                draw_rectangle(x1+dif_x,y1+dif_y,x2+dif_x,y2+dif_y,1);
               }
               //-- 
               
               //rotujeme - vykreslení obrysu
               if g[#_selected,i]=1 &amp;&amp; rotating==1 
               {         
                //připravit     
                var shad=surface_create(x2-x1,y2-y1);
                surface_set_target(shad);
                 draw_clear_alpha(c_black,0.1); //úroveň krytí
                surface_reset_target();
                
                //kreslit
                draw_surface_ext(shad,x1+zsx,y1+zsy,g[#_xscale,i],g[#_yscale,i],mean(dif_x,dif_y),c_white,1);
                surface_free(shad);
               }
               //-- 
               
               /****/
               
             }
             //---
           }
      }    
           
           
     
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vykreslení obrysů všech surfaces
 

// Ono to trochu ztrácí při depths smysl...
  
 set_font(7,c_black,1,-1);
 for(i=0;i&lt;max_surfaces;i++) //opět všechny, aby obrysy a infa byly vždy nahoře, jinak to lze nacpat do kreslení samotných surfaces
  {
      if g[#_id,i]!=0  //nulový index je rezervován pro ssource a nula v grid znamená prázdné pole
          {
          
          if surface_exists(g[#_id,i]) //pokud surface neexistuje, nekreslí se nic
             {
             var x1,y1,x2,y2;
               
               if source_mode==0
               {
                x1=g[#_x1,i];
                y1=g[#_y1,i];
                x2=g[#_x2,i];
                y2=g[#_y2,i];
               }
        
              
             
               if source_mode==1
               {
                x1=g[#_xs1,i];
                y1=g[#_ys1,i];
                x2=g[#_xs2,i];
                y2=g[#_ys2,i];
               }

                
              // Pokud je povrch vybraný, pushneme vykreslení okraje
              if (g[#_selected,i]) {clr(c_purple); draw_rectangle(x1,y1,x2,y2,1); draw_rectangle(x1+1,y1+1,x2-1,y2-1,1); clr();}
              
              // Pro zoomované povrchy se zobrazí dvojitý obdélník spojený v rozích linkou
                //zoomshift
                if (g[#_xscale,i]!=1 || g[#_yscale,i]!=1)
                 {
                  var zsx=((1-g[#_xscale,i])*(x2-x1)*!source_mode)/2;
                  var zsy=((1-g[#_yscale,i])*(y2-y1)*!source_mode)/2;

                  //zoomed rectangle 
                  var zx1=x1+zsx;
                  var zy1=y1+zsy;
                  var zx2=x2-zsx;
                  var zy2=y2-zsy;
                  
                  draw_rectangle(x1,y1,x2,y2,1);    
                  // vykreslíme iterovaný povrch
                  draw_arrow(x1,y1,zx1,zy1,8);
                  draw_arrow(x2,y1,zx2,zy1,8);
                  draw_arrow(x1,y2,zx1,zy2,8);
                  draw_arrow(x2,y2,zx2,zy2,8);
                  
                  draw_rectangle(zx1,zy1,zx2,zy2,1);                        
                 }
             //-- 
             
             // Pokud je povrch rotovaný, zobrazí se rotace
             if (g[#_angle,i]!=0)
                 {
                   var size_r=min(x2-x1,y2-y1);
                   var scaler=0;
                   var scaler_step=1/abs(g[#_angle,i]);
                   draw_set_alpha(0.5);
                   
                   for(a=min(0,g[#_angle,i]);a&lt;=max(0,g[#_angle,i]);a++)
                   {
                   draw_line(x1,y1,x1+lengthdir_x(size_r*scaler,a),y1+lengthdir_y(size_r*scaler,a));
                   scaler+=scaler_step;
                   }
                   draw_set_alpha(1);
                 }
             //-- 
                          
              
               
               draw_text(x1,y1, "ID: "+string(g[#_id,i])+' at '+string(i) );
               draw_text(x1,y1+20, "Depth: "+string(g[#_depth,i]));
               
               // Pokud je povrch označený jako aktivní, vypíšeme to
               if g[#_selected,i]==1 {draw_text(x1,y1+40, "active");}
               if g[#_baked,i]==1 {draw_text(x1,y1+60, "baked");}
           }
     }
 }
      

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vykresleni mrizky a kurzoru

//vykreslení mřížky
if guides
{

//presun mrizky
var mrx=mrizka_x;
var mry=mrizka_y;
var mx0=0;              //od
var mx1=room_width;     //do
var my0=0;              //od
var my1=room_height;    //do
var mrw=mrizka_w;
var mrh=mrizka_h;

if grid_moving
{
mrx+=dif_x;
mry+=dif_y;
}

if grid_resizing
{
mrw+=dif_x;
mrh+=dif_y;

mrw=clamp(mrw,2,room_width);
mrh=clamp(mrh,2,room_height);

}

clr(c_black,0.1);

for(ix=mx0;ix&lt;=mx1;ix+=mrw) draw_line(ix+mrx,my0,ix+mrx,my1);
for(iy=my0;iy&lt;=my1;iy+=mrh) draw_line(mx0,iy+mry,mx1,iy+mry);

clr(c_black,1);
}


//vykreslení kurzoru
if window_get_cursor()==cr_none
{
draw_circle_colour(Mx,My,4,c_gray,c_gray,false);

if alarm[0]&lt;cursor_stay
{
draw_circle_colour(Mx,My,5,c_yellow,c_gray,false);
draw_circle_colour(Mx,My,8,c_dkgray,c_gray,false);
draw_circle_colour(Mx,My,12,c_silver,c_gray,false);
}
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="111">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///přepíná přichycení na mřížku

mrizka_snap=!mrizka_snap;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="106">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///přepíná  úpravu zdroje a cíle
source_mode=!source_mode;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="66">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///stav zapečení vybraných on/off


   for(i=0;i&lt;max_surfaces;i++) //pro všechny povrchy
   {
    if g[#_selected,i]==1 //které jsou vybrány
      g[#_baked,i]=!g[#_baked,i]; //zapečení on/off   
   }
   
   
   
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="36">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///synchronizuje zdroj obsahu s aktuální polohou povrchu a v source_mode polohu povrchu s polohou zdroje obsahu

   for(i=0;i&lt;max_surfaces;i++) //pro všechny povrchy
   {
    if g[#_selected,i]==1 //které jsou vybrány
    {
    if source_mode!=0
     {
      g[#_x1,i]=g[#_xs1,i]; //sync target
      g[#_y1,i]=g[#_ys1,i];  
      g[#_x2,i]=g[#_xs2,i]; 
      g[#_y2,i]=g[#_ys2,i];
     }
      else
     {
      g[#_xs1,i]=g[#_x1,i]; //sync source
      g[#_ys1,i]=g[#_y1,i];  
      g[#_xs2,i]=g[#_x2,i]; 
      g[#_ys2,i]=g[#_y2,i];
     }  
    }  
   }
   
   
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
