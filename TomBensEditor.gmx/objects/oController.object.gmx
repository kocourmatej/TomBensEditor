<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///grid init

max_surfaces=5;    //pro rychlejší ladění ( později přidat nebo dynamicky zvětšovat pomocí resize )
grid_arguments=16;

//LIST ARGUMENTŮ V MAKRECH

g=ds_grid_create(max_surfaces,grid_arguments);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicializace ostatních proměnných

// Proměnné pro práci se selekcí a vytváření povrchů
clicked          = 0; // Kontrola, zda bylo tento step kliknuto myší (bool)
creating_surface = 0; // Zda vytvářime surface (bool)
clicked_index    = -1; // Index vybraného povrchu, -1 značí žádný povrch (int32)
moving           = 0; // Zda je tažen (bool)
source_mode      = 0; // režim manipulace se zdrojem obsahu
layer            = 0; // aktuální hloubka pro nové surfaces - čím vyšší, tím je hlouběji
group            = -1; // aktuální group pro nové surfaces: -1 znamená bez group


//průběžné
start_xx = 0;  // X-ová souřadnice
start_yy = 0;  // Y-ová souřadnice
dif_x=0;       // rozdílová X
dif_y=0;       // rozdílová Y

//jeden surface jako zdroj obsahu - vytvoření v Draw
ssource=surface_create(room_width,room_height); // je nutné vytvořit alespoň jeden povrch, aby se index 0 nevyskytoval v grid



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Přemisťování surface

if moving==1
{
dif_x= mouse_x - start_xx  ;  // X-ová souřadnice
dif_y= mouse_y - start_yy  ;  // Y-ová souřadnice
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///moving - zastavení

    if (oCursorMode.value==MOVE) // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    moving = 0; // Posunujeme povrch
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///dokončení tvorby nového a zápis do ds_

if (oCursorMode.value==ADD) // Pokud tvoříme povrch
   { 
        surface_x = abs(mouse_x-start_xx); // Šířka surface (prozatím unused)
        surface_y = abs(mouse_y-start_yy); // Výška surface (prozatím unused)
        
     if surface_x&gt;0 &amp;&amp; surface_y&gt;0 //invalid surface dimensions
       {   
        var position_in_grid=g_new_place();   
        
        g[#position_in_grid,_id]=surface_create(surface_x,surface_y); // Do listu uložíme nový povrch
        
        if surface_exists(g[#position_in_grid,_id]) 
              show_debug_message('New surface was created: '+string(g[#position_in_grid,_id])+' at '+string(position_in_grid))
         else show_debug_message('New surface was NOT created! ');
        
        // Do adekvátních sloupců gridu zapíšeme souřadnice x1,y1,x2,y2   
        g[#position_in_grid,_x2]=max(mouse_x,start_xx); 
        g[#position_in_grid,_y2]=max(mouse_y,start_yy);       
        g[#position_in_grid,_x1]=min(mouse_x,start_xx);
        g[#position_in_grid,_y1]=min(mouse_y,start_yy);
        
        //default pro flags
        g[#position_in_grid,_baked]=0;
        g[#position_in_grid,_selected]=0;
        g[#position_in_grid,_depth]=layer;
        g[#position_in_grid,_group]=group;
        
        //source je na začátku tam, kde poloha
        g[#position_in_grid,_xs2]=g[#position_in_grid,_x2]; 
        g[#position_in_grid,_ys2]=g[#position_in_grid,_y2];       
        g[#position_in_grid,_xs1]=g[#position_in_grid,_x1];
        g[#position_in_grid,_ys1]=g[#position_in_grid,_y1];
        
       }
       
        creating_surface = 0; // Povrch je vytvořen, můžeme vynulovat proměnnou
   }
 
   
       
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///výběr a zničení


   //clicked_index = -1;  // Nastavíme vybraný povrch na "nevybraný"
   
   //if (ds_list_size(surface_list) &gt; 0) // Je zbytečné kopírovat podmínku - for je cyklus s podmínkou na začátku, při size 0 se nic neprovede - DÍKY
      
   if oCursorMode.value==SELECT
   {
      for (a = 0; a &lt; ds_list_size(surface_list); a++) // Iterujeme list povrchů
            {
            //if (mouse_x &gt; start_x[| a] &amp;&amp; mouse_x &lt; temp_x2[| a] &amp;&amp; mouse_y &gt; start_y[| a] &amp;&amp; mouse_y &lt; temp_y2[| a]) // Pokud je myš v čtverci representující iterovaný povrch   
            if point_in_rectangle(mouse_x,mouse_y,start_x[| a],start_y[| a],temp_x2[| a],temp_y2[| a])
               {
                selected[| a]=!selected[| a]; //select - deselect
                break; // Dál už iterovat nepotřebujeme
               }      
            }           
    }    
    
    if (oCursorMode.value = KILL) // Pakliže máme vybraný stav kursoru jako "kill"
       {
       for (a = 0; a &lt; ds_list_size(surface_list); a++) // Iterujeme list povrchů
            {
           if point_in_rectangle(mouse_x,mouse_y,start_x[| a],start_y[| a],temp_x2[| a],temp_y2[| a]) // Pokud máme kursor na povrchu
               {
                // Ze všech potřebných seznamů odebereme adekvátní položku, už aby se to sjednotilo do ds_grid, tohle je na zbláznění 
                ds_list_delete(surface_list,a);
                ds_list_delete(start_x,a);
                ds_list_delete(start_y,a);
                ds_list_delete(temp_x2,a);
                ds_list_delete(temp_y2,a);
                ds_list_delete(selected,a);
                ds_list_delete(baked,a);
                
                break; // Ukončíme cykl
               }      
            }           
      }    
        

   
   
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start move

    if (oCursorMode.value==MOVE)&amp;&amp; moving==0 // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    moving = 1; // Posunujeme povrchy
   
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = mouse_x;  // X-ová souřadnice
    start_yy = mouse_y;  // Y-ová souřadnice
    
    }
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start tvoření nového   
    
    if (oCursorMode.value==ADD) // Pokud není vybraný žádný povrch a kliklo se, vytváříme nový povrch
    {
    creating_surface = 1; // Vytváříme nový povrch
    
    
    // Do 2D vektoru si uložíme souřadnice kurzoru(x,y)
    start_xx = mouse_x;  // X-ová souřadnice
    start_yy = mouse_y;  // Y-ová souřadnice
    
    }
        

   
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// na zvážení - HTML export se pravděpodobně konat nebude
draw_set_color(c_black);
draw_set_alpha(1);




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vyplnění zdrojového surface
if !surface_exists(ssource) ssource=surface_create(room_width,room_height);

// už by měl existovat - vyplnit
  surface_set_target(ssource);
  draw_background_tiled_ext
    ( 
    background0,   //index
    image_index,0, //poloha - jízda
    2,2,            //zvětšit
    c_white,1      //blend
    )
   surface_reset_target();
   
if source_mode==1
{
 draw_surface(ssource,x,y);
}   


 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Obdélník při vytváření

if (oCursorMode.value==ADD) &amp;&amp; (creating_surface==1) // Pokud tvoříme povrch
   {
    draw_rectangle(start_xx,start_yy,mouse_x,mouse_y,1); // Vykreslíme obdélník od počátečních k aktuálním souřadnicím kurzoru
   }
   
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vykreslení všech surfaces

   
       //první by se měly vykreslit ty s nejnižší depth, stejné depth pak podle pořadí vytvoření
       //ds_grid_sort(g,_id,sestupne); 
       //ds_grid_sort(g,_depth,sestupne);
       
   for(i=0;i&lt;max_surfaces;i++)
    {
          
     if g[#i,_id]!=0  //nulový index je rezervován pro ssource a nula v grid znamená prázdné pole
          {
             var x1,y1,x2,y2;
               
               if source_mode==0
               {
                x1=g[#i,_x1];
                y1=g[#i,_y1];
                x2=g[#i,_x2];
                y2=g[#i,_y2];
               }
               
          //pokud surface neexistuje, vytvoří se podle záznamu
          /*
            if !surface_exists(g[#i,_id])
              {
               var w=x2-x1;
               var h=y2-y1;
               
               if w&gt;0 &amp;&amp; h&gt;0 g[#i,_id]=surface_create(w,h);                  
              }
              */
              
             if surface_exists(g[#i,_id]) //pokud přesto neexistuje, nekreslí se nic
             {
               if source_mode==1
               {
                x1=g[#i,_xs1];
                y1=g[#i,_ys1];
                x2=g[#i,_xs2];
                y2=g[#i,_ys2];
               }
                    
  
               
               if g[#i,_selected]=1 &amp;&amp; oCursorMode.value==MOVE //pohybujeme
               {
                x1+=dif_x;
                y1+=dif_y;
                x2+=dif_x;
                y2+=dif_y;
               }

        
               //obsah kopíruje source pokud není zapečen
               if g[#i,_baked]==0 surface_copy_part(g[#i,_id],0,0,ssource,g[#i,_xs1],g[#i,_ys1],g[#i,_xs2]-g[#i,_xs1],g[#i,_ys2]-g[#i,_ys1]);
        
               draw_surface(g[#i,_id],x1,y1); // vykreslíme iterovaný povrch
             }
           }
      }    
           
           
     
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vykreslení obrysů všech surfaces

   
   
 set_font(7,c_black,1,-1);
 for(i=0;i&lt;max_surfaces;i++) //opět všechny, aby obrysy a infa byly vždy nahoře, jinak to lze nacpat do kreslení samotných surfaces
  {
     if g[#i,_id]==0 break; //nulový index je rezervován pro ssource a nula v grid znamená prázdné pole
      else
          {        
             var x1,y1,x2,y2;
               
               if source_mode==0
               {
                x1=g[#i,_x1];
                y1=g[#i,_y1];
                x2=g[#i,_x2];
                y2=g[#i,_y2];
               }
               else
               {
                x1=g[#i,_xs1];
                y1=g[#i,_ys1];
                x2=g[#i,_xs2];
                y2=g[#i,_ys2];
               }
               
               
            if g[#i,_selected]=1 &amp;&amp; oCursorMode.value==MOVE //pohybujeme
            {
             x1+=dif_x;
             y1+=dif_y;
             x2+=dif_x;
             y2+=dif_y;
            }
               
               
               // obdélník přes surface
               draw_set_alpha(0.4);
               //draw_rectangle(x1,y1,x2,y2,0);
               draw_set_alpha(0.7);
               draw_rectangle(x1,y1,x2,y2,1);
               draw_set_alpha(1);
               draw_text(x1,y1, "ID: "+string(i));
               
               // Pokud je povrch označený jako aktivní, vypíšeme to
               if g[#i,_selected]==1 {draw_text(x1,y1+20, "active");}
               if g[#i,_baked]==1 {draw_text(x1,y1+40, "baked");}
           }
     }
           

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="66">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///stav zapečení vybraných on/off


   //clicked_index = -1;  // Nastavíme vybraný povrch na "nevybraný"
   
   //if (ds_list_size(surface_list) &gt; 0) // Je zbytečné kopírovat podmínku - for je cyklus s podmínkou na začátku, při size 0 se nic neprovede
      

      for (a = 0; a &lt; ds_list_size(surface_list); a++) // Iterujeme list povrchů
            {
                if selected[| a]==1  baked[| a]=!baked[| a]; //select - deselect
            }           

        

   
   
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
